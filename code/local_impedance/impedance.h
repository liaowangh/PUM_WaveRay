
void impedance(std::shared_ptr<lf::mesh::Mesh> mesh) {
    int n = mesh->NumEntities(2); // number of vertices
    std::vector<std::unordered_set<int>> adjacent_vertex(n);
    std::vector<std::unordered_set<int>> adjacent_cell(n);
    for(const lf::mesh::Entity* cell: mesh->Entities(0)) {
        nonstd::span<const lf::mesh::Entity* const> points = cell->SubEntities(2);
        for(int i = 0; i < 3; ++i) {
            int p_idx = mesh->Index(points[i]);
            adjacent_cell[p_idx].insert(mesh->Index(cell));
            
            for(int j = 0; j < 3; ++j) {
                ajdacent_vertex[p_idx].insert(mesh->Index(points[j]));
            }
        }
    }
    // now adjacent_vertex and adjacent_cell only contain one layer of cells and points
    // need to extend it to contain two layers
    auto adjacent_vertex_copy = adjacent_vertex;
    auto adjacent_cell_copy = adjacent_cell;
    for(int i = 0; i < n; ++i) {
        for(auto j: adjacent_vertex_copy[i]) {
            for(auto k: adjacent_cell_copy[j]) {
                adjacent_vertex[i].insert(k);
            }
        }
        for(auto j: adjacent_cell_copy[i]) {
            for(auto k: adjacent_cell_copy[j]){
                ajdacent_cell[i].insert[k];
            }
        }
    }
    // now ajdacent_vertex[i] contains index of vertices in vertex patch i
    // ajdacent_cell[i] contains index of cell in vertex patch i
    
}

std::vector<double> HE_FEM::mesh_width() {
    std::vector<double> width(L_+1); // L_+1 meshes in total
    auto mesh = getmesh(0); // coarest mesh
    double h0 = 0.0;

    for(const lf::mesh::Entity* cell: mesh->Entities(0)) {
        const lf::geometry::Geometry *geo_ptr = cell->Geometry();

        // coordiante matrix: 2x3
        auto vertices = geo_ptr->Global(cell->RefEl().NodeCoords());
        for(int i = 0; i < vertices.cols(); ++i) {
            for(int j = i + 1; j < vertices.cols(); ++j) {
                double tmp = (vertices.col(i) - vertices.col(j)).norm();
                if(tmp > h0) {
                    h0 = tmp;
                }
            }
        }
    }
    width[0] = h0;
    for(int i = 1; i <= L_; ++i) {
        // because meshes are generated by uniform regular refinement
        width[i] = width[i-1] / 2;
    }
    return width;
}

lf::mesh::utils::CodimMeshDataSet<bool> 
HE_FEM::outerBdy_selector(size_type l) {
    auto mesh = getmesh(l);
    auto outer_boundary{lf::mesh::utils::flagEntitiesOnBoundary(mesh, 1)};
    if(hole_exist_) {
        auto outer_nr = reader_->PhysicalEntityName2Nr("outer_boundary");
        auto inner_nr = reader_->PhysicalEntityName2Nr("inner_boundary");

        // modify it to classify inner and outer boundary
        for(const lf::mesh::Entity* edge: mesh->Entities(1)) {
            if(outer_boundary(*edge)) {
                // find a boundary edge, need to determine if it's outer boundary
                const lf::mesh::Entity* parent_edge = edge;
                for(int i = l; i > 0; --i) {
                    parent_edge = mesh_hierarchy_->ParentEntity(i, *parent_edge);
                }
                if(reader_->IsPhysicalEntity(*parent_edge, inner_nr)) {
                    // it is the inner boundary
                    outer_boundary(*edge) = false;
                }
            }
        }
    }
    return outer_boundary;
}

